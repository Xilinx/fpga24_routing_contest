# Copyright (C) 2023, Advanced Micro Devices, Inc.  All rights reserved.
#
# Author: Zak Nafziger, AMD
#
# SPDX-License-Identifier: MIT
#

import argparse
import warnings
import networkx as nx
from wa import WirelengthAnalyzer
from xcvup_device_data import xcvupDeviceData

class FindVivadoCriticalPathInWirelengthGraph:
    """
    This class parses a Vivado timing report generated from a routed FPGA
    Interchange Format Physical Netlist, and determines whether or not the path
    reported in the timing report exists in the graph generated by the
    Wirelength Analyzer.
    """

    def __init__(self, timing_report, physical_netlist, test_case):
        """
        This method is the main entry point for the comparison.

        Args:
            timing_report: name of the vivado timing report generated from a
            routed FPGA Interchange Format Physical Netlist
            physical_netlist: the FPGA Interhcange Format Physical Netlist
            test_case: name of the current test case
        """
        self.wa = WirelengthAnalyzer(physical_netlist, 0)
        self.vivado_critical_path = self.parse_vivado_timing_report(timing_report)
        self.wa.join_nets()
        self.reduce_wirelength_graph()
        self.wirelength_path = self.wa.find_longest_path()
        self.test_case = test_case
        if len(self.vivado_critical_path) > 0:
            assert len(self.wirelength_path)/2 <= len(self.vivado_critical_path), "Wirelength Analyzer path longer than Vivado critical path"
        self.success = self.match_vivado_and_wirelength_paths()

    def parse_vivado_timing_report(self, timing_report_filename):
        """
        This method parses a vivado timing report, and returns a list of tuples
        containing information about the BELs along the path

        Args:
            timing_report_filename: the filename of the timing report to parse
        Returns:
            a list of 3-tuples, organized as (site name, bel name, cell name)
            with each element a string
        """
        sl = self.wa.phys.strList
        path = []
        cell_to_bel_idx = {}
        # Extract sites and cell names directly from the timing report
        with open(timing_report_filename, 'r') as rpt:
            stop = False
            found_source = False
            timing_driven = False
            while not stop:
                if not found_source:
                    ln1 = rpt.readline() # source clk pin
                    if '(MET)' in ln1:
                        timing_driven = True
                    ln1 = ln1.split()
                    if len(ln1) < 1:
                        continue
                    elif ln1[0].startswith('SLICE') or ln1[0].startswith('DSP'):
                        found_source = True
                        if timing_driven:
                            rpt.readline()
                        continue
                    elif ln1[0].startswith('AP'):
                        found_source = True
                        rpt.readline()
                        continue
                    else:
                        continue
                else:
                    ln1 = rpt.readline() # location and element type
                    ln2 = rpt.readline() # cell name
                    ln3 = rpt.readline() # net name
                    stop = '-----' in ln2 # quit when we find the sink pin
                    if stop:
                        ln1 = ln1.split()
                        site = ln1[0]
                        cell_name = ln1[-1]
                        cell_name = '/'.join(cell_name.split('/')[0:-1])
                        cell_to_bel_idx[cell_name] = len(path)
                        path.append((site, cell_name))
                        continue
                ln1 = ln1.split()
                ln2 = ln2.split()
                site = ln1[0]
                cell_name = ln2[-1]
                cell_name = '/'.join(cell_name.split('/')[0:-1])
                cell_to_bel_idx[cell_name] = len(path)
                path.append((site, cell_name))

        # Vivado timing reports use package pin names instead of site names
        # maintain a minimal table of conversions
        IO_to_site = {
            'AP24' : 'IOB_X1Y13'
        }

        # Determine cell <-> BEL correspondence via the Physical Netlist
        for placement in self.wa.phys.placements:
            bel_idx = cell_to_bel_idx.get(sl[placement.cellName])
            if bel_idx is not None:
                old_element = path[bel_idx]
                site = IO_to_site.get(old_element[0], old_element[0])
                new_element = (site, sl[placement.bel], old_element[1])
                path[bel_idx] = new_element

        path = [x for x in path if x[1] not in {'BUFCE', 'BUFG'}]

        return path

    def reduce_wirelength_graph(self):
        """
        Once the Wirelength Analyzer's internal graph has been constructed this
        method removes all nodes that are not associated with BELs in the
        critical path found by Vivado. Finding the longest path in the resultant
        reduced graph should produce the critical path reported by Vivado.
        """
        sl = self.wa.phys.strList

        nodes_to_remove = set()
        found_bels = set()
        vcp_bels = {(element[0], element[1]) for element in self.vivado_critical_path}
        for n in self.wa.G:
            seg = self.wa.G.nodes[n]['segment']
            if seg.which() == 'belPin':
                site = sl[seg.belPin.site]
                bel = sl[seg.belPin.bel]
                element = (site, bel)
                if element in vcp_bels:
                    found_bels.add(element)
                else:
                    nodes_to_remove.add(n)
            else:
                nodes_to_remove.add(n)

        assert vcp_bels == found_bels, "Could not find all BELs on Vivado critical path in Wirelength Analyzer graph "+str(vcp_bels)+"\n\n"+str(found_bels)

        for n in nodes_to_remove:
            self.wa.G.remove_node(n)

    def match_vivado_and_wirelength_paths(self):
        """
        This method compares the longest path found in a reduced Wirelength
        Analyzer graph to the critical path reported by Vivado. Since the
        Wirelength Analyzer always considers DSPs to be timing endpoints,
        whereas Vivado may report a critical path through a DSP, the path found
        in the Wirelength Analyzer graph is always expected to be subpath of
        the Vivado critical path. As such this method assumes that the two
        paths match is every element on the wirelength path is found on
        the Vivado path, in the same order.

        Returns:
            true if every BEL along self.wirelength_path is found in order along
            self.vivado_critical_path
        """
        sl = self.wa.phys.strList
        first_bel = self.wa.G.nodes[self.wirelength_path[0]]['segment'].belPin.bel
        second_bel = self.wa.G.nodes[self.wirelength_path[1]]['segment'].belPin.bel
        if first_bel == second_bel:
            wa_edges = zip(self.wirelength_path[1::2], self.wirelength_path[2::2])
        else:
            wa_edges = zip(self.wirelength_path[0::2], self.wirelength_path[1::2])
        wa_path = []
        wl_incr = []

        wl = 0
        for e in wa_edges:
            seg = self.wa.G.nodes[e[0]]['segment']
            site = seg.belPin.site
            bel = seg.belPin.bel
            cell_name = sl[self.wa.placements[(site, bel)].cellName]
            wa_path.append((sl[site], sl[bel], cell_name))
            assert self.wa.G.has_edge(*e)
            incr = self.wa.G.get_edge_data(*e)['wirelength']
            wl += incr
            wl_incr.append(incr)
        seg = self.wa.G.nodes[self.wirelength_path[-1]]['segment']
        site = seg.belPin.site
        bel = seg.belPin.bel
        cell_name = sl[self.wa.placements[(site, bel)].cellName]
        wa_path.append((sl[site], sl[bel], cell_name))

        wa_idx = 0
        matched_paths = []
        for vivado_element in self.vivado_critical_path:
            matched = False
            wl = ''
            if wa_idx < len(wa_path):
                wa_element = wa_path[wa_idx]
            else:
                wa_element = None
            if wa_element == vivado_element:
                matched = True
                if wa_idx < len(wl_incr):
                    wl = wl_incr[wa_idx]
                wa_idx += 1
            elif wa_idx > 0 and wa_idx < len(wa_path):
                warnings.warn("Discontinuous Path In "+self.test_case+": Requires manual investigation. May be due to equal length forks.")
            matched_paths.append((vivado_element, matched, wl))
        self.print_matched_paths(matched_paths)
        return wa_idx == len(wa_path)

    def print_matched_paths(self, matched_paths):
        """
        Format and print the matched paths data as a variable width table

        Args:
            matched_paths: list of match tuples produced by
            match_vivado_and_wirelength_paths()
        """
        site_width = 0
        bel_width = 0
        wl_width = 0
        total_wl = 0
        for e in matched_paths:
            if len(e[0][0]) > site_width:
                site_width = len(e[0][0])
            if len(e[0][1]) > bel_width:
                bel_width = len(e[0][1])
            if e[2] != '':
                total_wl += e[2]
                if len(str(e[2])) > wl_width:
                    wl_width = len(str(e[2]))

        wl_header = 'WL INCR'
        site_header = 'SITE'
        bel_header = 'BEL'
        wl_width = max(wl_width, len(wl_header))
        site_width = max(site_width, len(site_header))
        bel_width = max(bel_width, len(bel_header))
        print("================================================================================")
        print(self.test_case)
        print('Total wirelength of matched path:', total_wl)
        sep = '|'
        header = (' {:<'+str(wl_width)+'} '+sep).format(wl_header)
        header += ' MATCH ' + sep
        header += (' {:<'+str(site_width)+'} '+sep).format(site_header)
        header += (' {:<'+str(bel_width)+'} '+sep).format(bel_header)
        header += ' CELL NAME'
        print(header)
        horiz = '-'*(wl_width+2)+'+' + '-'*7+'+' + '-'*(site_width+2)+'+' + '-'*(bel_width+2)+'+' + '-'*(80 - (wl_width + 7 + site_width + bel_width + 10))
        print(horiz)
        for element in matched_paths:
            line = (' {:<'+str(wl_width)+'} '+sep).format(element[2])
            if element[1]:
                line += '   T   ' + sep
            else:
                line += '   F   ' + sep
            line += (' {:<'+str(site_width)+'s} '+sep).format(element[0][0])
            line += (' {:<'+str(bel_width)+'s} '+sep).format(element[0][1])
            line += (' {:<s}').format(element[0][2])
            print(line)
        print("================================================================================")

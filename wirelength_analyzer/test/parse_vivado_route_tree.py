# Copyright (C) 2023, Advanced Micro Devices, Inc.  All rights reserved.
#
# Author: Zak Nafziger, AMD
#
# SPDX-License-Identifier: MIT
#

import networkx as nx

class ParseVivadoRouteTree:
    """
    This class contains a very simple parser to read Vivado's route tree output
    into a Networkx graph. The resultant graph can then be compared to the
    graph generated by the wirelength analyzer module. This class exists solely
    to support unit testing.
    """

    def __init__(self, source_file):
        self.source_file = source_file
        self.G = None
        self.roots = []
        self.leaves = []

    def build_tree_from_net(self):
        """
        Main entry point for the parser. runs the preprocessor, lexer, and
        parser and then asserts that the result of parsing is indeed a tree.
        """
        raw = self._preprocess(self.source_file)
        tokens = self._lex(raw)
        self.G = self._parse(tokens)
        self._assert_tree()
        self._format_edge_data()

    def _format_edge_data(self):
        """
        Converts Vivado's pip descriptions into 3 tuples of the format
        (tile, wire0, wire1) for easy comparison with FPGA Interchange Format
        PhysPIP objects.
        """
        for e in self.G.edges():
            old_dat = self.G.get_edge_data(*e)['segment']
            new_dat = None
            if old_dat == None:
                new_dat = (None, None, None)
            else:
                old_dat = old_dat.split('/')
                tile = old_dat[0]
                old_dat = old_dat[1].split('->')
                wire0 = old_dat[0].split('.')[1]
                wire1 = old_dat[1].replace('>', '')
                new_dat = (tile, wire0, wire1)
            self.G[e[0]][e[1]]['segment'] = new_dat

    def _assert_tree(self):
        """
        Confirm that the graph is tree-like (i.e. has exactly one root, some
        leaves, and |edges| + 1 == |nodes|)
        """
        for n in self.G.nodes:
            if self.G.in_degree(n) == 0:
                self.roots.append(n)
            if self.G.out_degree(n) == 0:
                self.leaves.append(n)
        assert len(self.roots) == 1
        assert len(self.leaves) != 0
        assert len(self.G.edges) + 1 == len(self.G.nodes)

    @staticmethod
    def _preprocess(source):
        """
        Preprocessor for Vivado graph format source

        Args:
            source: A file containing vivado graph source
        Returns:
            A list of source lines ready to be lexed
        """
        raw = []
        start = False
        with open(source, 'r') as f:
            l = f.readline()
            while ('------------------------------------------' not in l) or not start:
                l = f.readline()
                if 'Subtree: 0' in l:
                    start = True
                elif start:
                    raw.append(l)
        return raw[0:-1]

    @staticmethod
    def _lex(raw):
        """
        A simple lexer for Vivado's graph format. Tokens are basically one of
        brackets, braces, or strings

        Args:
            raw: List of strings each corresponding to one line of Vivado graph
            format source
        Returns:
            A list of tokens ready to be parsed
        """
        tokens = []
        raw = ''.join(raw)
        raw = raw.split()
        it = iter(range(len(raw)))
        for i in it:
            if raw[i] in ['{', '}', '[', ']']:
                tokens.append(raw[i])
            elif raw[i] in ['[{', '}]', '{[', ']}']:
                tokens.append(raw[i][0])
                tokens.append(raw[i][1])
            elif '(' in raw[i]:
                current_token = raw[i]
                while ')' not in raw[i]:
                    i = next(it)
                    current_token += raw[i]
                tokens.append(current_token)
            else:
                tokens.append(raw[i])
        return tokens

    @staticmethod
    def _parse(tokens):
        """
        Simple parser to convert the following BNF:
            Route-Tree := Subtree ...
            Subtree    := [Trunk] Stem
            Trunk      := {Root Branch|Stem ...}
            Branch     := {Branch|Stem ...} Stem
            Stem       := Node Dontcare Pip
            Root       := Node Dontcare
        which describes Vivado's graph format, To a tree. Made up of a set of
        mutually recursive embedded functions that each process one element of
        the BNF grammar.

        Args:
            tokens: List of tokens 
        Returns:
            A graph corresponding to the description in the initial source file
        """
        G = nx.DiGraph()
        last_node = None
        def _parse_branches_and_stems(bslist):
            """
            Helper function to parse a list that looks like: Branch|Stem ...
            which occurs in both Trunks and Branches
            """
            nonlocal last_node
            nonlocal G
            i = 0
            while i < len(bslist):
                if bslist[i] == '{':
                    braces = 1
                    branch = [bslist[i]]
                    i += 1
                    while braces > 0:
                        if bslist[i] == '{':
                            braces += 1
                        if bslist[i] == '}':
                            braces -= 1
                        branch.append(bslist[i])
                        i += 1
                    for j in range(3):
                        branch.append(bslist[i])
                        i += 1
                    branch_point = last_node
                    _branch(branch)
                    last_node = branch_point
                else:
                    _stem([bslist[i], bslist[i+1], bslist[i+2]])
                    i = i+3

        def _route_tree(tree):
            i = 0
            while i < len(tree):
                if tree[i] == '[':
                    subtree = []
                    while tree[i] != ']':
                        subtree.append(tree[i])
                        i +=1
                    for j in range(4):
                        subtree.append(tree[i])
                        i += 1
                    _subtree(subtree)

        def _subtree(subtree):
            _trunk(subtree[1:-4])
            _stem(subtree[-3:])

        def _trunk(trunk):
            trunk = trunk[1:-1] # drop outer braces
            _root(trunk[0:2])
            _parse_branches_and_stems(trunk[2:])

        def _branch(branch):
            _parse_branches_and_stems(branch[1:-4])
            _stem(branch[-3:])

        def _stem(stem):
            nonlocal last_node
            nonlocal G
            G.add_edge(last_node, stem[0], segment=stem[2])
            last_node = stem[0]

        def _root(root):
            nonlocal last_node
            nonlocal G
            G.add_node(root[0])
            last_node = root[0]

        _route_tree(tokens)
        return G
